# app_v2.py
import os, io, tempfile, re, json, numpy as np, pandas as pd
from PIL import Image, ImageDraw, ImageFont
import gradio as gr
from datetime import datetime

# ---------------------------
# 0) 기본 설정
# ---------------------------
FONT_CANDIDATES = [
    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
    "/System/Library/Fonts/Supplemental/Arial Bold.ttf",
]

def _font(sz):
    for p in FONT_CANDIDATES:
        if os.path.exists(p):
            try: return ImageFont.truetype(p, sz)
            except: pass
    return ImageFont.load_default()

def rgb_hex(c): return "#{:02X}{:02X}{:02X}".format(*c)
def hex_rgb(h): 
    h = h.strip()
    if not h.startswith("#"): h = "#"+h
    return tuple(int(h[i:i+2],16) for i in (1,3,5))

# 임시 큐레이션(26SS_08/09/12) — CSV가 없을 때만 사용
CURATED_26SS = {
    "26SS_08": {"h_rgb": (33,83,145)},
    "26SS_09": {"h_rgb": (33,83,145)},
    "26SS_12": {"h_rgb": (33,83,145)},
}

THREADBOOK_PATH = "imjae_threadbook_full.csv"
USE_THREADBOOK = os.path.exists(THREADBOOK_PATH)
thread_df = pd.read_csv(THREADBOOK_PATH) if USE_THREADBOOK else None

# ---------------------------
# 1) 원단 지배색 추출
# ---------------------------
def extract_dominant_rgb(img_pil, k=6):
    im = img_pil.convert("RGB").resize((120,120))
    q = im.quantize(colors=k)
    pal = q.getpalette()
    counts = sorted(q.getcolors(), reverse=True)  # (count, idx)
    # 너무 하양/검정 제외
    for cnt, idx in counts:
        r,g,b = pal[3*idx:3*idx+3]
        if not (r>240 and g>240 and b>240) and not (r<15 and g<15 and b<15):
            return (r,g,b)
    idx = counts[0][1]
    return tuple(pal[3*idx:3*idx+3])

# ---------------------------
# 2) 26SS 로직 CSV 파서
# ---------------------------
def parse_26ss_logic(csv_path_or_none):
    """
    반환: {
      "codes": ["26SS_01", ...],
      "h_map": {"26SS_01": (r,g,b), ...},
      "swatch_map": {"26SS_01": (r,g,b)}  # 옵션(있을 때만)
    }
    """
    h_map, swatch_map = {}, {}
    codes = []
    if not csv_path_or_none or not os.path.exists(csv_path_or_none):
        # CSV가 없으면 큐레이션만 사용
        for c,v in CURATED_26SS.items():
            h_map[c] = v["h_rgb"]
            codes.append(c)
        return {"codes": sorted(codes), "h_map": h_map, "swatch_map": swatch_map}

    df = pd.read_csv(csv_path_or_none)
    cols = [c.lower() for c in df.columns]
    # 허용 스키마
    # 1) code,h_r,h_g,h_b  OR  2) code,h_hex
    # (선택) fabric_r,fabric_g,fabric_b  또는 fabric_hex
    for _, row in df.iterrows():
        code = str(row[[c for c in df.columns if c.lower()=="code"][0]]).strip()
        # h 추출
        if set(["h_r","h_g","h_b"]).issubset(cols):
            hr = int(row[[c for c in df.columns if c.lower()=="h_r"][0]])
            hg = int(row[[c for c in df.columns if c.lower()=="h_g"][0]])
            hb = int(row[[c for c in df.columns if c.lower()=="h_b"][0]])
            h_rgb = (hr,hg,hb)
        else:
            # h_hex
            hcol = [c for c in df.columns if c.lower()=="h_hex"]
            if not hcol: 
                continue  # 스키마 불충분
            h_rgb = hex_rgb(str(row[hcol[0]]))
        h_map[code] = h_rgb
        codes.append(code)

        # fabric 스와치(있을 때만)
        if set(["fabric_r","fabric_g","fabric_b"]).issubset(cols):
            fr = int(row[[c for c in df.columns if c.lower()=="fabric_r"][0]])
            fg = int(row[[c for c in df.columns if c.lower()=="fabric_g"][0]])
            fb = int(row[[c for c in df.columns if c.lower()=="fabric_b"][0]])
            swatch_map[code] = (fr,fg,fb)
        else:
            fhex = [c for c in df.columns if c.lower()=="fabric_hex"]
            if fhex and isinstance(row[fhex[0]], str) and row[fhex[0]].strip():
                swatch_map[code] = hex_rgb(str(row[fhex[0]]))
    return {"codes": sorted(set(codes)), "h_map": h_map, "swatch_map": swatch_map}

# ---------------------------
# 3) 실북 Top4 매칭
# ---------------------------
def nearest_threads(target_rgb, df, top_n=4):
    arr = df[['R','G','B']].values.astype(float)
    dist = np.linalg.norm(arr - np.array(target_rgb, dtype=float), axis=1)
    out = df.assign(dist=dist).sort_values('dist').head(top_n)
    return [{
        "Thread_No": str(r['Thread_No']),
        "Thread_Name": str(r['Thread_Name']),
        "RGB": (int(r['R']), int(r['G']), int(r['B']))
    } for _, r in out.iterrows()]

def looks_suspicious(threads):
    def sat(rgb):
        r,g,b = [c/255 for c in rgb]
        mx, mn = max(r,g,b), min(r,g,b)
        return 0 if mx==0 else (mx-mn)/mx
    return sum(1 for t in threads if sat(t["RGB"]) < 0.15) >= 3

# ---------------------------
# 4) 렌더러
# ---------------------------
def render_preview(fabric_rgb, threads, h_rgb, W=1600, H=900, bg=(255,255,255)):
    margin = 40; left_w = 800
    img = Image.new("RGB",(W,H),bg)
    d = ImageDraw.Draw(img)
    font_big   = _font(520)
    font_title = _font(36)
    font_small = _font(24)

    # 좌측: 원단 배경 + h
    left = (margin, margin, margin+left_w, H-margin)
    d.rectangle(left, fill=fabric_rgb)
    tx, ty, bx, by = d.textbbox((0,0), "h", font=font_big)
    d.text((margin + left_w//2 - (bx-tx)//2, margin + (H-2*margin)//2 - (by-ty)//2),
           "h", font=font_big, fill=h_rgb)
    d.text((margin+16, H-margin-46),
           f"Fabric RGB {fabric_rgb}  {rgb_hex(fabric_rgb)}",
           font=font_title, fill=(255,255,255))

    # 우측: 2x2 칩
    right_w = W - left_w - 3*margin
    grid_gap = margin//2
    cell_w = (right_w - grid_gap)//2
    cell_h = (H - 3*margin)//2
    start_x = margin*2 + left_w
    start_y = margin
    for i, t in enumerate(threads[:4]):
        r = i//2; c = i%2
        x0 = start_x + c*(cell_w + grid_gap)
        y0 = start_y + r*(cell_h + margin)
        x1 = x0 + cell_w; y1 = y0 + cell_h
        d.rectangle((x0,y0,x1,y1), fill=t["RGB"])
        # 라벨
        strip_h = 120
        d.rectangle((x0, y1-strip_h, x1, y1), fill=(255,255,255))
        d.text((x0+14, y1-strip_h+12),
               f"#{t['Thread_No']}  {t['Thread_Name']}",
               font=font_title, fill=(0,0,0))
        d.text((x0+14, y1-strip_h+58),
               f"RGB {t['RGB']}  {rgb_hex(t['RGB'])}",
               font=font_small, fill=(0,0,0))
    return img

def save_temp(img, fmt="png"):
    suffix = f".{fmt.lower()}"
    fn = f"Hazzys_{datetime.now().strftime('%Y%m%d_%H%M%S')}{suffix}"
    path = os.path.join(tempfile.gettempdir(), fn)
    img.convert("RGB").save(path, fmt.upper())
    return path

# ---------------------------
# 5) 파이프라인
# ---------------------------
def pipeline(fabric_img, ss_code, out_fmt, logic_csv_path):
    if fabric_img is None:
        return None, None, {"error":"원단 이미지를 업로드하세요."}

    # 26SS 로직 로드(있으면 26개 전부; 없으면 08/09/12 큐레이션)
    logic = parse_26ss_logic(logic_csv_path)
    codes = logic["codes"]
    h_map = logic["h_map"]
    sw_map = logic["swatch_map"]

    fabric_rgb = extract_dominant_rgb(fabric_img)

    # 코드 선택(auto 지원: fabric 스와치가 있을 때만)
    pick = ss_code
    if ss_code == "auto" and sw_map:
        arr = np.array([sw_map[c] for c in codes])
        dist = np.linalg.norm(arr - np.array(fabric_rgb, dtype=float), axis=1)
        pick = codes[int(np.argmin(dist))]
    if pick not in h_map:
        # 최후의 보루
        pick = codes[0]

    h_rgb = h_map[pick]

    # 실북 Top4(있으면 사용, 품질 가드)
    threads = []
    if USE_THREADBOOK:
        try:
            top4 = nearest_threads(h_rgb, thread_df, top_n=4)
            if not looks_suspicious(top4): threads = top4
        except Exception:
            pass
    # 실북 없거나 의심스럽다면 라벨만 표시되는 더미(색은 h_rgb 톤 변형)
    if not threads:
        threads = [
            {"Thread_No":"—","Thread_Name":"Nearest-1","RGB":h_rgb},
            {"Thread_No":"—","Thread_Name":"Nearest-2","RGB":tuple(max(min(int(c*0.9),255),0) for c in h_rgb)},
            {"Thread_No":"—","Thread_Name":"Nearest-3","RGB":tuple(max(min(int(c*0.8),255),0) for c in h_rgb)},
            {"Thread_No":"—","Thread_Name":"Nearest-4","RGB":tuple(max(min(int(c*0.7),255),0) for c in h_rgb)},
        ]

    img = render_preview(fabric_rgb, threads, h_rgb)
    dl_path = save_temp(img, fmt=out_fmt)
    meta = {
        "fabric_rgb": {"rgb": fabric_rgb, "hex": rgb_hex(fabric_rgb)},
        "26ss_code": pick,
        "h_rgb": {"rgb": h_rgb, "hex": rgb_hex(h_rgb)},
        "threads": [{"no":t["Thread_No"], "name":t["Thread_Name"],
                     "rgb":t["RGB"], "hex": rgb_hex(t["RGB"])} for t in threads]
    }
    return img, dl_path, meta

# ---------------------------
# 6) Gradio UI
# ---------------------------
with gr.Blocks(theme=gr.themes.Soft(primary_hue="blue")) as demo:
    gr.Markdown("## HAZZYS Embroidery Color Recommender (v2)\n원단 이미지를 올리면 미리보기와 다운로드 파일을 즉시 제공합니다.")
    with gr.Row():
        inp = gr.Image(type="pil", label="Fabric image (png/jpg)")
        logic = gr.File(type="filepath", label="26SS 로직 CSV (선택) — code,h_r,h_g,h_b 또는 code,h_hex")
    with gr.Row():
        ss  = gr.Dropdown(choices=["26SS_08","26SS_09","26SS_12"],
                          value="26SS_09", label="26SS code")
        fmt = gr.Radio(choices=["png","jpg"], value="png", label="Output format")
    go = gr.Button("Generate")

    out_img  = gr.Image(type="pil", format="png", label="Preview")
    out_file = gr.File(label="Download result")
    out_json = gr.JSON(label="Details")

    # CSV 업로드 시, 코드 드롭다운 자동 갱신
    def on_logic_change(p):
        logic = parse_26ss_logic(p)
        choices = ["auto"] + logic["codes"] if logic["codes"] else ["26SS_08","26SS_09","26SS_12"]
        default = "auto" if "auto" in choices else (logic["codes"][0] if logic["codes"] else "26SS_09")
        return gr.update(choices=choices, value=default)
    logic.change(on_logic_change, logic, ss)

    go.click(
        lambda img, code, ofmt, csvpath: pipeline(img, code, ofmt, csvpath),
        [inp, ss, fmt, logic],
        [out_img, out_file, out_json]
    )

if __name__ == "__main__":
    demo.launch()  # 외부 공유 필요하면 demo.launch(share=True)
